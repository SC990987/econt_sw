{
    "CH_ALIGNER_[N]_force_ch_outputs": "If set to 1, force the outputs of CH_N coming from the channel aligners to the CH_ALIGNER_[N]_user_word_0 pattern.",
    "CH_ALIGNER_[N]_prbs_chk_en": "If set to 1, enable the internal PRBS check (32-bit by default).",
    "CH_ALIGNER_[N]_patt_sel": "If set to 1 and CH_ALIGNER_[N]_patt_en=1, enable the four CH_ALIGNER_[N]_user_word_* to be sent sequentially and in a loop as outputs of the CH_ALIGNER_[N].",
    "CH_ALIGNER_[N]_prbs28_en": "If set to 1 and CH_ALIGNER_[N]_patt_en=1, enable the internal PRBS pattern to be sent as output of the CH_ALIGNER_[N].",
    "CH_ALIGNER_[N]_patt_en": "If set to 1, enable a pattern (user word or PRBS) to be sent as output of the CH_ALIGNER_[N].",
    "CH_ALIGNER_[N]_sel_override_en": "If set to 1, override the select value for eRx N.",
    "CH_ALIGNER_[N]_per_ch_align_en": "If set to 1, (and ALIGNER_snapshot_en=1) enable automatic alignment.",
    "CH_ALIGNER_[N]_sel_override_val": "Value of select to be overwriten in manual alignment mode.",
    "CH_ALIGNER_[N]_seed_in": "16-bit seed for internal PRBS pattern generator.",
    "CH_ALIGNER_[N]_user_word_0": "32-bit word to be sent as output of the ALIGNER in first BX.",
    "CH_ALIGNER_[N]_user_word_1": "32-bit word to be sent as output of the ALIGNER in second BX.",
    "CH_ALIGNER_[N]_user_word_2": "32-bit word to be sent as output of the ALIGNER in third BX.",
    "CH_ALIGNER_[N]_user_word_3": "32-bit word to be sent as output of the ALIGNER in fourth BX.",
    "CH_EPRXGRP_[N]_phaseSelect": "Phase value to be used in the static mode of the ePortRX.",
    "CH_EPRXGRP_[N]_trainChannel": "Can be used to request a phase training for each channel individually. From lpGBT docs: The phase training for a channel N can be initiated by generating a positive pulse (set CH_EPRXGRP_[N]_trainChannel bit to one and reset it to zero). In bench tests, 0->1 transition just caused a different phaseSelect RO value than the one chosen at power-up.",
    "CH_EPRXGRP_[N]_resetChannels": "",
    "CH_EPRXGRP_[N]_dllResetReq": "",
    "ALIGNER_dbg_fc_cnt_clr": "Clear FC debug counters.",
    "ALIGNER_i2c_snapshot_en": "Enable triggering 192-bit i2c snapshot. The snapshot is triggered by a 0->1 transition on the ALIGNER_snapshot_arm i2c bit.",
    "ALIGNER_snapshot_en": "Enable 192-bit i2c snapshot.",
    "ALIGNER_snapshot_arm": "If 0->1 transition and ALIGNER_i2c_snapshot_en=1 the snapshot is triggered.",
    "ALIGNER_match_pattern_val": "64-bit training pattern expected to be sent by HGCROC when issuing a link-reset-ROCT. HGCROC pattern is 0x9cccccccaccccccc.",
    "ALIGNER_match_mask_val": "64-bit mask for ALIGNER_match_pattern_val.",
    "ALIGNER_orbsyn_hdr_mask": "Orbit sync header mask.",
    "ALIGNER_orbsyn_hdr_val": "Orbit sync header value (0x9).",
    "ALIGNER_orbsyn_cnt_max_val": "BX counter rollover (3563).",
    "ALIGNER_orbsyn_cnt_load_val": "Changes when BCR is sent relative to BC0.",
    "ALIGNER_orbsyn_cnt_snapshot": "Changes BX at which 6-BX-snapshot occurs.",
    "ALIGNER_idle_hdr_mask": "IDLE header mask.",
    "ALIGNER_idle_hdr_val": "IDLE header value (0xa).",
    "ERRTOP_wren_msk_top": "",
    "ERRTOP_wren_err_top": "",
    "ERRTOP_clr_on_read_top": "",
    "ERRTOP_wr_data_top": "",
    "ERRTOP_err_wr_data": "",
    "EPRXGRP_TOP_enableReInit": "",
    "EPRXGRP_TOP_dllInitSMForceClockEnable": "",
    "EPRXGRP_TOP_dllConfirmCountSelect": "",
    "EPRXGRP_TOP_dllUnLockThreshold": "",
    "EPRXGRP_TOP_dllReLockThreshold": "",
    "EPRXGRP_TOP_dllLockThreshold": "",
    "EPRXGRP_TOP_trackMode": "If set to 0, use the static phase mode of the ePortRX and the phase of each channel will be set by CH_EPRXGRP_[N]_phaseSelect.",
    "EPRXGRP_TOP_dataGatingEnable": "",
    "EPRXGRP_TOP_dllCoarseLockDetection": "",
    "EPRXGRP_TOP_dllCurrentSet": "",
    "FCTRL_reset_b_fc_counters": "Reset fast command counters.",
    "FCTRL_force_fc_error": "Force a fast command error.",
    "FCTRL_invert_command_rx": "Invert Fast Command data.",
    "FCTRL_PreL1AOffset": "",
    "FCTRL_EdgeSel_T1": "Select the edge of the FC clock at which the FC data stream will lock.",
    "FMTBUF_tx_sync_word": "32-bit eTx IDLE word (0x122)",
    "FMTBUF_buff_t1": "Threshold parameter T1. It uses the number of 16-bit words in buffer (Nbuf) and number of 16-bit words in full data packet for current BX (Nbxc). If (Nbuf+Nbxc)>T1: use truncated type (Condition 1), else, look into T2,T3 thresholds to determine whether to use truncated type.",
    "FMTBUF_buff_t2": "If Nbuf>T2 and not (Condition 1), use Conditions 2 or 3, else, use full type.",
    "FMTBUF_buff_t3": "If (Conditions 2 or 3) and Nbxc>T3, use full type, else, use truncated type.",
    "FMTBUF_eporttx_numen": "Number of eTx active. Minimum 2.",
    "FMTBUF_use_sum": "In threshold algorithm, send either the sum of all TC (0) or the sum of all transmitted TC (1). The module sum is encoded with 5E+3M.",
    "FMTBUF_stc_type": "STC algorithm type, 0: STC4 5E+4M.",
    "FMTBUF_mask_ae": "",
    "FMTBUF_mask_ae2": "",
    "MFC_mux_select_[N]": "",
    "MFC_cal_[N]": "",
    "MFC_ALGORITHM_SEL_DENSITY_algo_select": "",
    "MFC_ALGORITHM_SEL_DENSITY_algo_density": "",
    "ALGO_threshold_val_[N]": "",
    "ALGO_drop_lsb": "",
    "ERX_ch_[N]_set_common_mode": "",
    "ERX_ch_[N]_ch_equalizer": "",
    "ERX_ch_[N]_enable_termination": "",
    "ERX_ch_[N]_invert_data": "",
    "ERX_ch_[N]_enable": "",
    "ERX_mux_[N]_set_common_mode": "",
    "ERX_mux_[N]_ch_equalizer": "",
    "ERX_mux_[N]_enable_termination": "",
    "ERX_mux_[N]_invert_data": "",
    "ERX_mux_[N]_enable": "",
    "ETX_ch_[N]_pre_emphasis_strength": "",
    "ETX_ch_[N]_pre_emphasis_width": "",
    "ETX_ch_[N]_pre_emphasis_mode": "",
    "ETX_ch_[N]_drive_strength": "",
    "ETX_ch_[N]_invert_data": "",
    "ETX_mux_[N]_pre_emphasis_strength": "",
    "ETX_mux_[N]_pre_emphasis_width": "",
    "ETX_mux_[N]_pre_emphasis_mode": "",
    "ETX_mux_[N]_drive_strength": "",
    "ETX_mux_[N]_invert_data": "",
    "ETX_mux_[N]_enable": "",
    "PLL_enableDes": "",
    "PLL_enableSer": "",
    "PLL_clktreeCdisable": "",
    "PLL_clktreeBdisable": "",
    "PLL_clktreeAdisable": "",
    "PLL_clk2G56enable": "",
    "PLL_clk1G28enable": "",
    "PLL_clk640Menable": "",
    "PLL_clk320Menable": "",
    "PLL_clk160Menable": "",
    "PLL_clk80Menable": "",
    "PLL_clk40Menable": "",
    "PLL_enablePhaseShifter": "",
    "PLL_COenableFD": "",
    "PLL_COenableCDR": "",
    "PLL_COdisDataCounterRef": "",
    "PLL_COdisDESvbiasgen": "",
    "PLL_ENABLE_CDR_R": "",
    "PLL_dataMuxCfg": "",
    "PLL_CONFIG_P_FF_CDR": "",
    "PLL_CONFIG_P_CDR": "",
    "PLL_CONFIG_I_FLL": "",
    "PLL_CONFIG_I_CDR": "",
    "PLL_CONFIG_FF_CAP": "",
    "PLL_CONFIG_FF_CAP_WL": "",
    "PLL_PLL_R_CONFIG_WL": "",
    "PLL_CONFIG_P_PLL_WL": "",
    "PLL_CONFIG_I_PLL_WL": "",
    "PLL_CONFIG_I_FLL_WL": "",
    "PLL_CONFIG_P_FF_CDR_WL": "",
    "PLL_CONFIG_P_CDR_WL": "",
    "PLL_CONFIG_I_CDR_WL": "",
    "PLL_CBOvcoCapSelect": "",
    "PLL_COrefClkSel": "",
    "PLL_COoverrideVc": "",
    "PLL_VCObypass": "",
    "PLL_COenablePLL": "",
    "PLL_COconnectPLL": "",
    "PLL_COconnectCDR": "",
    "PLL_vcoRailMode": "",
    "PLL_vcoDAC": "",
    "PLL_PLL_R_CONFIG": "",
    "PLL_CONFIG_P_PLL": "",
    "PLL_CONFIG_I_PLL": "",
    "PLL_BIASGEN_CONFIG": "",
    "PLL_FrameAlignerIsLocked": "",
    "PLL_disableFrameAlignerLockControl": "",
    "PLL_enableControlOverride": "",
    "PLL_enableCapBankOverride": "",
    "PLL_rxLockMode": "",
    "PLL_mode": "",
    "PLL_lfEnable": "",
    "PLL_waitPLLTime": "",
    "PLL_waitCDRTime": "",
    "PLL_selEndOfCount": "",
    "PLL_lfUnLockThrCounter": "",
    "PLL_lfReLockThrCounter": "",
    "PLL_lfLockThrCounter": "",
    "PLL_phase_of_enable_1G28": "",
    "PLL_toclkgen_disVCO": "",
    "PLL_toclkgen_disSER": "",
    "PLL_toclkgen_disEXT": "",
    "PLL_toclkgen_disEOM": "",
    "PLL_toclkgen_disDES": "",
    "PLL_toclkgen_disCLK": "",
    "PLL_ref_clk_sel": "",
    "PLL_output_clk_sel": "",
    "PLL_refClk_setCommonMode": "",
    "PLL_refClk_enableTermination": "",
    "PLL_refClk_enableRx": "",
    "PLL_tofbDiv_skip": "",
    "PLL_reset_eTx_par_enable_intr": "",
    "PLL_reset_pll_not_locked_intr": "",
    "AUTOENCODER_weights_[M]_[N]": "",
    "MISC_run": "",
    "MISC_rw_ecc_err_clr": "",
    "CH_ALIGNER_[N]_prbs_chk_err": "",
    "CH_ALIGNER_[N]_orbsyn_fc_err": "",
    "CH_ALIGNER_[N]_orbsyn_arr_err": "",
    "CH_ALIGNER_[N]_orbsyn_hdr_err": "",
    "CH_ALIGNER_[N]_align_seu_err": "",
    "CH_ALIGNER_[N]_hdr_mm_err": "",
    "CH_ALIGNER_[N]_snapshot_dv": "",
    "CH_ALIGNER_[N]_pattern_match": "",
    "CH_ALIGNER_[N]_select": "",
    "CH_ALIGNER_[N]_snapshot": "Trailing 128-bits of aligner snapshot for eRx [N]",
    "CH_ALIGNER_[N]_snapshot2": "Leading 64-bits of aligner snapshot for eRx [N]",
    "CH_ALIGNER_[N]_hdr_mm_cntr": "",
    "CH_ALIGNER_[N]_orbsyn_hdr_err_cnt": "",
    "CH_ALIGNER_[N]_orbsyn_arr_err_cnt": "",
    "CH_ALIGNER_[N]_orbsyn_fc_err_cnt": "",
    "CH_ALIGNER_[N]_prbs_chk_err_cnt": "",
    "CH_ERR_[N]_raw_error_err_raw_dat": "",
    "CH_ERR_[N]_raw_error_hdr_mm_err": "",
    "CH_ERR_[N]_raw_error_align_seu_err": "",
    "CH_ERR_[N]_raw_error_orbsyn_hdr_err": "",
    "CH_ERR_[N]_raw_error_orbsyn_arr_err": "",
    "CH_ERR_[N]_raw_error_orbsyn_fc_err": "",
    "CH_ERR_[N]_raw_error_prbs_chk_err": "",
    "CH_ERR_[N]_error_mask_msk_dat": "",
    "CH_ERR_[N]_error_data_err_out": "",
    "CH_ERR_[N]_error_data_err_dat": "",
    "CH_EPRXGRP_[N]_channelLocked": "",
    "CH_EPRXGRP_[N]_dllInstantLock": "",
    "CH_EPRXGRP_[N]_status_phaseSelect": "",
    "CH_EPRXGRP_[N]_dllState": "",
    "CH_EPRXGRP_[N]_dllstatus_dllLossOfLockCount": "",
    "CH_EPRXGRP_[N]_dllstatus_dllLockFilterState": "",
    "CH_EPRXGRP_[N]_dllstatus_dllLocked": "",
    "ALIGNER_dbg_fc_cnt": "",
    "ALIGNER_dbg_orbsyn_rcvd": "",
    "ALIGNER_dbg_lreset_rcvd": "",
    "ALIGNER_done": "",
    "ERRTOP_msk_dat_top": "",
    "ERRTOP_err_dat_top_err_out_top": "",
    "ERRTOP_err_dat_top_err_dat_top": "",
    "FCTRL_locked": "Is FastCommand block locked? After a reset, locked=0. If 3 IDLES in a row are successfully decoded (at the same phase, necessarily) then locked=1. It will stay locked=1 unless 3 IDLES in a row are decoded at a different phase than the originally locked phase. Then, it will to go to 0 and stay at 0 until 3 IDLES in a row are successfully decoded at the same phase, whether is the original phase or not.",
    "FCTRL_fc_error": "FastCommand error. error=1 whenever an IDLE is decoded at the wrong phase, or whenever the number of 1-bits in an 8-bit fast command is not 4. The fast commands are all DC-balanced, so every 8-bit fast command has four 1s and four 0s.",
    "FCTRL_command_rx_inverted": "",
    "FCTRL_fc_error_count": "",
    "FCTRL_lock_count": "",
    "FMTBUF_buffer_out_err": "",
    "PLL_ljCDRCapBankSearchActive": "",
    "PLL_smLocked": "",
    "PLL_smState": "",
    "PLL_endCounterRefClk": "",
    "PLL_endCounterVCO": "",
    "PLL_lfLossOfLockCount": "",
    "PLL_lfLocked": "",
    "PLL_lfInstLock": "",
    "PLL_lfState": "",
    "PLL_pll_not_locked_timeout": "",
    "PLL_parallel_enable_intrA": "",
    "PLL_parallel_enable_intrB": "",
    "PLL_parallel_enable_intrC": "",
    "PUSM_state": "",
    "MISC_ecc_err_cnt_single_chan_aligner_[N]": "",
    "MISC_ecc_err_cnt_single_chan_err_[N]": "",
    "MISC_ecc_err_cnt_single_chan_eprxgrp_[N]": "",
    "MISC_ecc_err_cnt_single_chan_err_12": "",
    "MISC_ecc_err_cnt_single_aligner": "",
    "MISC_ecc_err_cnt_single_err_top": "",
    "MISC_ecc_err_cnt_single_eprxgrp_top": "",
    "MISC_ecc_err_cnt_single_fast_ctrl_decoder": "",
    "MISC_ecc_err_cnt_single_formatter_buffer": "",
    "MISC_ecc_err_cnt_single_mux_fix_calib": "",
    "MISC_ecc_err_cnt_single_algorithm": "",
    "MISC_ecc_err_cnt_single_erx": "",
    "MISC_ecc_err_cnt_single_etx": "",
    "MISC_ecc_err_cnt_single_pll": "",
    "MISC_ecc_err_cnt_single_misc": "",
    "MISC_ecc_err_cnt_double_chan_aligner_[N]": "",
    "MISC_ecc_err_cnt_double_chan_err_[N]": "",
    "MISC_ecc_err_cnt_double_chan_eprxgrp_[N]": "",
    "MISC_ecc_err_cnt_double_chan_err_12": "",
    "MISC_ecc_err_cnt_double_aligner": "",
    "MISC_ecc_err_cnt_double_err_top": "",
    "MISC_ecc_err_cnt_double_eprxgrp_top": "",
    "MISC_ecc_err_cnt_double_fast_ctrl_decoder": "",
    "MISC_ecc_err_cnt_double_formatter_buffer": "",
    "MISC_ecc_err_cnt_double_mux_fix_calib": "",
    "MISC_ecc_err_cnt_double_algorithm": "",
    "MISC_ecc_err_cnt_double_erx": "",
    "MISC_ecc_err_cnt_double_etx": "",
    "MISC_ecc_err_cnt_double_pll": "",
    "MISC_ecc_err_cnt_double_misc": "",
    "MISC_ecc_err_cnt_parity_chan_aligner_[N]": "",
    "MISC_ecc_err_cnt_parity_chan_err_[N]": "",
    "MISC_ecc_err_cnt_parity_chan_eprxgrp_[N]": "",
    "MISC_ecc_err_cnt_parity_chan_err_12": "",
    "MISC_ecc_err_cnt_parity_aligner": "",
    "MISC_ecc_err_cnt_parity_err_top": "",
    "MISC_ecc_err_cnt_parity_eprxgrp_top": "",
    "MISC_ecc_err_cnt_parity_fast_ctrl_decoder": "",
    "MISC_ecc_err_cnt_parity_formatter_buffer": "",
    "MISC_ecc_err_cnt_parity_mux_fix_calib": "",
    "MISC_ecc_err_cnt_parity_algorithm": "",
    "MISC_ecc_err_cnt_parity_erx": "",
    "MISC_ecc_err_cnt_parity_etx": "",
    "MISC_ecc_err_cnt_parity_pll": "",
    "MISC_ecc_err_cnt_parity_misc": "",
    "CH_ERR_[N]_wren_mask": "",
    "CH_ERR_[N]_wren_err": "",
    "CH_ERR_[N]_clr_on_read": "",
    "CH_ERR_12_misc_interrupts": "",
    "CH_ERR_12_pll_not_locked": "",
    "CH_ERR_12_dll_not_locked": "",
    "CH_ERR_12_chns_not_locked": "",
    "CH_ERR_12_buffer_wr_ptr_overflow_err": "",
    "CH_ERR_12_fc_error_count_ne_zero": "",
    "CH_ERR_12_command_rx_inverted": ""
}
